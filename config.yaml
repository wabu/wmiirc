#
# High-level wmii configuration.
#
# Ruby code in this file has access
# to a CONFIG constant which contains
# the data in this configuration file.
#
#--
# Copyright 2006 Suraj N. Kurapati
# See the LICENSE file for details.
#++
##
# Appearance settings.
#
display:

  ##
  # Where to display the horizontal status bar?
  #
  # Possible choices are "top" and "bottom".
  #
  bar: bottom

  ##
  # The font to use in all text drawn by wmii.
  #
  font: xft:Monospace:pixelsize=10:antialias=1:hinting=1:hintstyle=hintfull:rgba=none

  ##
  # Thickness of client border (measured in pixels).
  #
  border: 1

  ##
  # Number of seconds a notice shoud be displayed.
  #
  notice: 5

  ##
  # Color schemes for everything drawn by wmii.
  #
  #   <scheme>: "<text> <background> <border>"
  #
  # You can find more color schemes at:
  #
  #   http://wmii.suckless.org/scripts_n_snips/themes
  #
  color:
    normal:   "#3A3A6A #EEEEEF #DADAEA"
    focus:    "#2A2A4A #CECEDE #5A5A8A"
    active:   "#3A3A6A #CECEDE #DADAEA"
    error:    "#8a1f11 #FBE3E4 #FBC2C4" # from http://www.blueprintcss.org
    notice:   "#514721 #FFF6BF #FFD324" # from http://www.blueprintcss.org
    success:  "#264409 #E6EFC2 #C6D880" # from http://www.blueprintcss.org

  ##
  # Color of desktop background.
  #
  background: "#eeeeef"

  ##
  # Settings for columns drawn by wmii.
  #
  #   mode: <the wmii "colmode" setting>
  #   rule: <the wmii "colrules" setting>
  #
  column:
    mode: default
    rule: |
      /art/ -> 17+83+17
      /.*/   -> 62+38 # Golden Ratio

  ##
  # Settings for taging clients
  #
  #   rule: <the wmii "tagrules" setting>
  #
  tag:
    rule: |
      /gimp:Gimp:Color Picker/ -> ~
      /gimp:Gimp:Open.*/ -> ~
      /gimp/ -> art
      /MPlayer/ -> ~
      /pidgin/ -> ~
      /xterm/ -> ~
      /xmessage/ -> ~
      /pavucontrol/ -> ~
      /alsamixer/ -> ~
      /wicd-client/ -> ~
      /./ -> sel

  ##
  # Self-refreshing buttons on the status bar.
  #
  #   - <button name>:
  #       refresh:  <number of seconds to wait before refreshing the content>
  #       content:  <Ruby code whose result is displayed as the content>
  #       click:    <Ruby code to handle mouse clicks on the status button.
  #                  This code has access to a "mouse_button" variable which is
  #                  an integer representing the mouse button that was clicked.>
  #
  # You can refresh a particular status button in Ruby using:
  #
  #   status "your button name"
  #
  # The horizontal order in which these buttons appear on the status
  # bar reflects the vertical order in which they are defined below.
  #
  status:
    - space:
        refresh: 600
        content: []

    - ifstat:
        init: @ifstat = File.popen("ifstat -nwi eth0 2")
        content: |
          if @ifstat.readline =~ /(\d+\.\d+)\s*(\d+\.\d+)/
            inw, out = $~.captures.map {|s| s.to_f}
            color = case
              when inw+out > 100 then CONFIG['display']['color']['notice']
              when inw+out >   1 then CONFIG['display']['color']['active']
            end
            [color, 'eth0', "%4.1f %4.1f" % [inw, out]]
          end
        click: |
          case mouse_button
          when 1 then toggle_launch :battmon, *%w[wihack -type DIALOG urxvt -e sudo iftop -i eth0]
          when 3 then toggle_launch :ifstat_bar, 'wicd-client', '-n'
          end

    - disk_space:
        refresh: 60
        content: |
          free, used, path = `df -h ~`.split.last(3)
          [path, used, 'used', free, 'free']

    - cpu_freq:
        refresh: 1
        content: |
          gov = File.open("/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"){|f| f.readline}.chomp
          [0,1].map {|c|
            freq = File.open("/sys/devices/system/cpu/cpu#{c}/cpufreq/scaling_cur_freq"){|f| f.readline}.to_f/1000000.0
            ["%.1f" % freq]
          }.unshift(gov)
        click: |
          case mouse_button
          when 1 then toggle_launch :system_load, *%w[wihack -type DIALOG urxvt -e top]
          end

    - system_load:
        refresh: 5
        content: |
          load_averages = File.read('/proc/loadavg').split.first(3)
          current_load  = load_averages.first.to_f

          # visually indicate the intensity of system load
          color = case
            when current_load > 5.0 then CONFIG['display']['color']['error']
            when current_load > 2.9 then CONFIG['display']['color']['notice']
            when current_load > 1.5 then CONFIG['display']['color']['active']
          end
          [color, *load_averages]
        click: |
          case mouse_button
          when 1 then toggle_launch :system_load, *%w[wihack -type DIALOG urxvt -e top]
          end

    - battmon:
        refresh: 10
        init: require 'tools/battmon.rb'
        content: battmon
        click: |
          case mouse_button
          when 1 then toggle_launch :battmon, *%w[wihack -type DIALOG urxvt -e sudo powertop]
          end

    - volume:
        refresh: 60
        content: @mixer.status
        click: |
          case mouse_button
          when 1 then @mixer.show_mixer
          when 2 then @mixer.toggle
          when 4 then @mixer.raise
          when 5 then @mixer.lower
          end
          status!('volume')

    - tray:
        refresh: 100
        content: |
          ['systemtray']

    - clock:
        refresh: 10
        content: |
          Time.now.strftime("%a %d.%m. %H:%M")
        click: |
          case mouse_button
          when 1 then launch 'orage', '-t'
          end

    #- music:
    #    refresh: 15
    #    content: |
    #      unless defined? @music
    #        require 'rubygems'
    #        gem 'librmpd', '~> 0.1'
    #        require 'librmpd'

    #        @music = MPD.new
    #      end

    #      unless @music.connected?
    #        @music.connect
    #      end

    #      music_state = (@music.stopped? || @music.paused?) ? '(-)' : '(>)'

    #      if song = @music.current_song
    #        artist    = song.artist
    #        title     = song.title || (f = song.file and File.basename(f))
    #        song_name = [artist, title].compact.join(': ')
    #      end

    #      [music_state, song_name].compact


##
# Interaction settings.
#
control:

  ##
  # The wmii "grabmod" setting.
  #
  grab: Mod4

  ##
  # Key bindings.
  #
  #   <key sequence>: <Ruby code to execute>
  #
  key:
    #---------------------------------------------------------------------------
    # focus
    #---------------------------------------------------------------------------

    Mod4-k: | # focus above client
      curr_view.select(:up) rescue nil

    Mod4-j: | # focus below client
      curr_view.select(:down) rescue nil

    Mod4-h: | # focus left client
      curr_view.select(:left) rescue nil

    Mod4-l: | # focus right client
      curr_view.select(:right) rescue nil

    Mod4-space: | # focus floating area (toggle)
      curr_view.select(:toggle)

    Mod4-comma: | # focus previous view
      prev_view.focus

    Mod4-period: | # focus next view
      next_view.focus

    Mod4-Shift-space: | # toggle floating
      curr_client.send :toggle

    Mod4-q: | # kill current client
      curr_client.kill

    Mod4-Shift-q: | # slay current client
      curr_client.slay

    # TODO: improve metaprogramming ;)
    # focus the view whose index or name equals the pressed number
    Mod4-1: focus_view( tags[0] || 1  )
    Mod4-2: focus_view( tags[1] || 2  )
    Mod4-3: focus_view( tags[2] || 3  )
    Mod4-4: focus_view( tags[3] || 4  )
    Mod4-5: focus_view( tags[4] || 5  )
    Mod4-6: focus_view( tags[5] || 6  )
    Mod4-7: focus_view( tags[6] || 7  )
    Mod4-8: focus_view( tags[7] || 8  )
    Mod4-9: focus_view( tags[8] || 9  )
    Mod4-0: focus_view( tags[9] || 10 )

    Mod4-less: &focus_last |
      focus_view(@last_view)

    Alt_R,semicolon: *focus_last

    # focus the view whose name begins with the pressed alphabet
    Alt_R,a: t = tags.grep(/^a/i).first and focus_view(t)
    Alt_R,b: t = tags.grep(/^b/i).first and focus_view(t)
    Alt_R,c: t = tags.grep(/^c/i).first and focus_view(t)
    Alt_R,d: t = tags.grep(/^d/i).first and focus_view(t)
    Alt_R,e: t = tags.grep(/^e/i).first and focus_view(t)
    Alt_R,f: t = tags.grep(/^f/i).first and focus_view(t)
    Alt_R,g: t = tags.grep(/^g/i).first and focus_view(t)
    Alt_R,h: t = tags.grep(/^h/i).first and focus_view(t)
    Alt_R,i: t = tags.grep(/^i/i).first and focus_view(t)
    Alt_R,j: t = tags.grep(/^j/i).first and focus_view(t)
    Alt_R,k: t = tags.grep(/^k/i).first and focus_view(t)
    Alt_R,l: t = tags.grep(/^l/i).first and focus_view(t)
    Alt_R,m: t = tags.grep(/^m/i).first and focus_view(t)
    Alt_R,n: t = tags.grep(/^n/i).first and focus_view(t)
    Alt_R,o: t = tags.grep(/^o/i).first and focus_view(t)
    Alt_R,p: t = tags.grep(/^p/i).first and focus_view(t)
    Alt_R,q: t = tags.grep(/^q/i).first and focus_view(t)
    Alt_R,r: t = tags.grep(/^r/i).first and focus_view(t)
    Alt_R,s: t = tags.grep(/^s/i).first and focus_view(t)
    Alt_R,t: t = tags.grep(/^t/i).first and focus_view(t)
    Alt_R,u: t = tags.grep(/^u/i).first and focus_view(t)
    Alt_R,v: t = tags.grep(/^v/i).first and focus_view(t)
    Alt_R,w: t = tags.grep(/^w/i).first and focus_view(t)
    Alt_R,x: t = tags.grep(/^x/i).first and focus_view(t)
    Alt_R,y: t = tags.grep(/^y/i).first and focus_view(t)
    Alt_R,z: t = tags.grep(/^z/i).first and focus_view(t)

    Alt_R,comma: | # focus view chosen from a menu
      if choice = key_menu(tags, 'show view:')
        focus_view choice
      end

    #---------------------------------------------------------------------------
    # move
    #---------------------------------------------------------------------------

    Mod4-Shift-h: | # move client to the left
      curr_client.send(:left) rescue nil

    Mod4-Shift-l: | # move client to the right
      curr_client.send(:right) rescue nil

    Mod4-Shift-j: | # move client down
      curr_client.send(:down) rescue nil

    Mod4-Shift-k: | # move client up
      curr_client.send(:up) rescue nil

    Mod4-Shift-space: | # move client up
      curr_client.send(:toggle) rescue nil

    Mod4-m,t: | # move grouping toward the top
      grouping.each {|c| c.send(:up) rescue nil }

    Mod4-m,n: | # move grouping toward the bottom
      grouping.each {|c| c.send(:down) rescue nil }

    Mod4-m,h: | # move grouping toward the left
      grouping.each {|c| c.send(:left) rescue nil }

    Mod4-m,s: | # move grouping toward the right
      grouping.each {|c| c.send(:right) rescue nil }

    Mod4-m,space: | # move grouping to floating area (toggle)
      grouping.each {|c| c.send(:toggle) rescue nil }

    Mod4-m,v: | # move grouping to chosen view
      #
      # Changes the tag (according to a menu choice) of
      # each grouped client and returns the chosen tag.
      #
      # The +tag -tag idea is from Jonas Pfenniger:
      #
      #   http://zimbatm.oree.ch/articles/2006/06/15/wmii-3-and-ruby
      #
      choices = tags.map {|t| [t, "+#{t}", "-#{t}"] }.flatten

      if target = key_menu(choices, 'tag as:')
        grouping.each do |c|
          case target
          when /^\+/ then c.tag $'
          when /^\-/ then c.untag $'
          else c.tags = target
          end
        end
      end

    Mod4-m,Delete: | # kill all clients in grouping
      grouping.each {|c| c.kill }

    # move grouping to the view whose index or name equals the pressed number
    Mod4-m,1: grouping.each {|c| c.tags = tags[0] || 1  }
    Mod4-m,2: grouping.each {|c| c.tags = tags[1] || 2  }
    Mod4-m,3: grouping.each {|c| c.tags = tags[2] || 3  }
    Mod4-m,4: grouping.each {|c| c.tags = tags[3] || 4  }
    Mod4-m,5: grouping.each {|c| c.tags = tags[4] || 5  }
    Mod4-m,6: grouping.each {|c| c.tags = tags[5] || 6  }
    Mod4-m,7: grouping.each {|c| c.tags = tags[6] || 7  }
    Mod4-m,8: grouping.each {|c| c.tags = tags[7] || 8  }
    Mod4-m,9: grouping.each {|c| c.tags = tags[8] || 9  }
    Mod4-m,0: grouping.each {|c| c.tags = tags[9] || 10 }

    # again for single clients
    Mod4-Shift-1: curr_client.tags = tags[0] || 1
    Mod4-Shift-2: curr_client.tags = tags[1] || 2
    Mod4-Shift-3: curr_client.tags = tags[2] || 3
    Mod4-Shift-4: curr_client.tags = tags[3] || 4
    Mod4-Shift-5: curr_client.tags = tags[4] || 5
    Mod4-Shift-6: curr_client.tags = tags[5] || 6
    Mod4-Shift-7: curr_client.tags = tags[6] || 7
    Mod4-Shift-8: curr_client.tags = tags[7] || 8
    Mod4-Shift-9: curr_client.tags = tags[8] || 9
    Mod4-Shift-0: curr_client.tags = tags[9] || 10

    #---------------------------------------------------------------------------
    # swap
    #---------------------------------------------------------------------------

    Mod4-Control-k: | # swap with above client
      curr_client.swap(:up) rescue nil

    Mod4-Control-j: | # swap with below client
      curr_client.swap(:down) rescue nil

    Mod4-Control-h: | # swap with left client
      curr_client.swap(:left) rescue nil

    Mod4-Control-l: | # swap with right client
      curr_client.swap(:right) rescue nil

    # swap current client with the column whose index equals the pressed number
    Mod4-Control-1: curr_client.swap 1
    Mod4-Control-2: curr_client.swap 2
    Mod4-Control-3: curr_client.swap 3
    Mod4-Control-4: curr_client.swap 4
    Mod4-Control-5: curr_client.swap 5
    Mod4-Control-6: curr_client.swap 6
    Mod4-Control-7: curr_client.swap 7
    Mod4-Control-8: curr_client.swap 8
    Mod4-Control-9: curr_client.swap 9
    Mod4-Control-0: curr_client.swap 10

    #---------------------------------------------------------------------------
    # column
    #---------------------------------------------------------------------------

    Mod4-z,w: | # apply equal-spacing layout to current column
      curr_area.layout = :default

    Mod4-z,Shift-w: | # apply equal-spacing layout to all columns
      curr_view.columns.each do |a|
        a.layout = :default
      end

    Mod4-z,v: | # apply stacked layout to current column
      curr_area.layout = 'stack-max'

    Mod4-z,Shift-v: | # apply stacked layout to all columns
      curr_view.columns.each do |a|
        a.layout = 'stack-max'
      end

    Mod4-z,m: | # apply maximized layout to current column
      curr_area.layout = 'stack+max'

    Mod4-z,Shift-m: | # apply maximized layout to all columns
      curr_view.columns.each do |a|
        a.layout = 'stack+max'
      end

    #---------------------------------------------------------------------------
    # group
    #---------------------------------------------------------------------------

    Mod4-g,g: | # toggle current client from grouping
      curr_client.group!

    Mod4-g,c: | # add clients in current area to grouping
      curr_area.group

    Mod4-g,Shift-c: | # remove clients in current area from grouping
      curr_area.ungroup

    Mod4-g,f: | # add clients in floating area to grouping
      Area.floating.group

    Mod4-g,Shift-f: | # remove clients in floating area from grouping
      Area.floating.ungroup

    Mod4-g,m: | # add clients in managed areas to grouping
      curr_view.managed_areas.each {|a| a.group }

    Mod4-g,Shift-m: | # remove clients in managed areas from grouping
      curr_view.managed_areas.each {|a| a.ungroup }

    Mod4-g,v: | # add clients in current view to grouping
      curr_view.group

    Mod4-g,Shift-v: | # remove clients in current view from grouping
      curr_view.ungroup

    Mod4-g,i: | # invert the grouping in the current view
      curr_view.group!

    Mod4-g,Shift-i: | # invert the grouping in all views
      Rumai.group!

    Mod4-g,d: | # add detached clients to group
      View.new(DETACHED_TAG).group!

    Mod4-g,n: | # remove all clients everywhere from grouping
      Rumai.ungroup

    #---------------------------------------------------------------------------
    # detach
    #---------------------------------------------------------------------------

    Mod4-d: | # detach grouping from current view
      grouping.each do |c|
        c.with_tags do
          delete curr_tag
          push DETACHED_TAG
        end
      end

    Mod4-Shift-d: | # attach most recently detached client
      v = View.new DETACHED_TAG

      if v.exist? and c = v.clients.last
        c.with_tags do
          delete DETACHED_TAG
          push curr_tag
        end
      end

    #---------------------------------------------------------------------------
    # zoom
    #---------------------------------------------------------------------------

    Mod4-f: | # zoom client to fullscreen (toggle)
      curr_client.fullscreen!

    Mod4-b: | # copy grouping to temporary view
      clients = grouping

      unless clients.empty?
        # determine new view
        if curr_tag =~ ZOOMED_SUFFIX
          src, num = $`, $1.to_i
          dst = "#{src}~#{num+1}"
        else
          dst = "#{curr_tag}~1"
        end

        # add clients to new view
        clients.each {|c| c.tag dst }

        # focus new view
        v = View.new dst
        v.focus
        v.arrange_in_grid

        # propagate focus into new view
        clients.first.focus v
      end

    Mod4-Shift-b: | # return grouping to original view
      clients = grouping

      unless clients.empty?
        src = curr_tag

        if src =~ ZOOMED_SUFFIX
          # determine new view
          dst = $`

          # remove clients from old view
          clients.each do |c|
            c.with_tags do
              delete src

              if empty?
                push dst
              else
                dst = last
              end
            end
          end

          # focus new view
          v = View.new dst
          v.focus

          # propagate focus into original view
          clients.first.focus v
        end
      end

    #---------------------------------------------------------------------------
    # arrange
    #---------------------------------------------------------------------------

    Mod4-z,t: | # arrange clients in current view like LarsWM does
      curr_view.arrange_as_larswm

    Mod4-z,g: | # arrange clients in current view like a grid
      curr_view.arrange_in_grid

    Mod4-z,d: | # arrange clients in current view like a diamond
      curr_view.arrange_in_diamond

    # apply grid layout with the pressed number of clients per column
    Mod4-z,1: curr_view.arrange_in_grid 1
    Mod4-z,2: curr_view.arrange_in_grid 2
    Mod4-z,3: curr_view.arrange_in_grid 3
    Mod4-z,4: curr_view.arrange_in_grid 4
    Mod4-z,5: curr_view.arrange_in_grid 5
    Mod4-z,6: curr_view.arrange_in_grid 6
    Mod4-z,7: curr_view.arrange_in_grid 7
    Mod4-z,8: curr_view.arrange_in_grid 8
    Mod4-z,9: curr_view.arrange_in_grid 9
    Mod4-z,0: curr_view.arrange_in_grid 9999 # make one giant column

    Mod4-z,z: | # collapse with the client above
      curr_view.ctl.write "grow sel sel up +9999"
    Mod4-z,x: | # collapse with the client below
      curr_view.ctl.write "grow sel sel down +9999"
    Mod4-z,k: | # grow the current cilent upwords
      curr_view.ctl.write "grow sel sel up +7"
    Mod4-z,k: | # grow the current cilent upwords
      curr_view.ctl.write "grow sel sel up +7"
    Mod4-z,j: | # grow the current cilent downwords
      curr_view.ctl.write "grow sel sel down +7"
    Mod4-z,Shift-j: | # shrik the current cilent upwords
      curr_view.ctl.write "grow sel sel up -7"
    Mod4-z,Shift-k: | # shrink the current cilent downwords
      curr_view.ctl.write "grow sel sel down -7"
    Mod4-z,h: | # grow the current collumn to the left
      curr_view.ctl.write "grow sel sel left +7"
    Mod4-z,l: | # grow the current collumn to the right
      curr_view.ctl.write "grow sel sel right +7"
    Mod4-z,Shift-l: | # shrink the current collumn to the left
      curr_view.ctl.write "grow sel sel left -7"
    Mod4-z,Shift-h: | # shrink the current collumn to the right
      curr_view.ctl.write "grow sel sel right -7"

    #---------------------------------------------------------------------------
    # menu
    #---------------------------------------------------------------------------

    Mod4-a: | # run internal action chosen from a menu
      if choice = key_menu(actions, 'run action:')
        action choice
      end

    Mod4-p: | # run external program chosen from a menu
      if choice = key_menu(@programs, 'run program:')
        launch choice
      end

    Mod4-e: | # focus client chosen from a menu
      choices = []

      clients.each_with_index do |c, i|
        choices << "%d. [%s] %s" % [i, c[:tags].read, c[:label].read.downcase]
      end

      if target = key_menu(choices, 'show client:')
        i = target.scan(/\d+/).first.to_i
        clients[i].focus
      end

    #---------------------------------------------------------------------------
    # launcher
    #---------------------------------------------------------------------------

    Mod4-x: | # launch a terminal
      #
      # Launch a new terminal and set its
      # working directory to be the same
      # as the currently focused terminal.
      #
      work = ENV['HOME']

      label = curr_client.label.read rescue ""

      # iterate in reverse order because
      # paths are usually at end of label
      label.split(' ').reverse_each do |s|
        path = File.expand_path(s)

        if File.exist? path
          unless File.directory? path
            path = File.dirname(path)
          end

          work = path
          break
        end
      end

      require 'fileutils'
      FileUtils.cd work do
        terminal
      end

    #---------------------------------------------------------------------------
    # music
    #---------------------------------------------------------------------------

    Mod4-Prior: | # previous song
      @music.previous rescue nil
      status 'music'

    Mod4-Next: | # next song
      @music.next rescue nil
      status 'music'

    Mod4-Return: | # pause song (toggle)
      begin
        if @music.stopped?
          @music.play
        else
          @music.pause = !@music.paused?
        end
      rescue
        # ignore
      end

      status 'music'

    #---------------------------------------------------------------------------
    # volume
    #---------------------------------------------------------------------------

    XF86AudioRaiseVolume: | # increase volume
      @mixer.raise
      status!('volume')

    XF86AudioLowerVolume: | # decrease volume
      @mixer.lower
      status!('volume')

    XF86AudioMute: | # mute volume (toggle)
      @mixer.toggle
      status!('volume')

  ##
  # Event handlers.
  #
  #   <event name>: <Ruby code to execute>
  #
  # The Ruby code has access to an "argv" variable which
  # is a list of arguments that were passed to the event.
  #
  event:
    CreateTag: |
      tag = argv[0]
      but = fs.lbar[tag]
      but.create unless but.exist?
      but.write "#{CONFIG['display']['color']['normal']} #{tag}"

    DestroyTag: |
      tag = argv[0]
      but = fs.lbar[tag]
      but.remove if but.exist?

    FocusTag: |
      tag = argv[0]
      but = fs.lbar[tag]
      but.write "#{CONFIG['display']['color']['focus']} #{tag}" if but.exist?

    UnfocusTag: |
      tag = argv[0]
      @last_view = tag
      but = fs.lbar[tag]
      but.write "#{CONFIG['display']['color']['normal']} #{tag}" if but.exist?

    UrgentTag: |
      tag = argv[1]
      but = fs.lbar[tag]
      but.write "#{CONFIG['display']['color']['notice']} #{tag}" if but.exist?

    NotUrgentTag: |
      tag = argv[1]
      but = fs.lbar[tag]
      color = curr_view.id == tag ? 'focus' : 'normal'
      but.write "#{CONFIG['display']['color'][color]} #{tag}" if but.exist?

    LeftBarClick: &LeftBarClick |
      mouse_button, view_id = argv
      case mouse_button.to_i
      when 4 then
        prev_view.focus
      when 5 then
        next_view.focus
      else 
        focus_view view_id
      end

    ##
    # allows the user to drag a file over a
    # view button and activate that view while
    # still holding on to their dragged file!
    #
    LeftBarDND: *LeftBarClick

    RightBarClick: |
      status_click *argv.reverse

    Unresponsive: |
      client_id = argv[0]
      client = Client.new(client_id)

      IO.popen("#{XMESSAGE} -nearmouse -file - -buttons Kill,Wait -print", 'w+') do |f|
        f.puts 'The following client is not responding.', ""
        f.puts client.inspect
        f.puts client.label.read

        f.puts "", 'What would you like to do?'
        f.close_write

        if f.read.chomp == 'Kill'
          client.slay
        end
      end

    Notice: |
      unless defined? @notice_mutex
        require 'thread'
        @notice_mutex = Mutex.new
      end

      Thread.new do
        # prevent notices from overwriting each other
        @notice_mutex.synchronize do
          button = fs.rbar['!notice']
          button.create unless button.exist?

          # display the notice
          message = argv.join(' ')

          LOG.info message # also log it in case the user is AFK
          button.write "#{CONFIG['display']['color']['notice']} #{message}"

          # clear the notice
          sleep [1, CONFIG['display']['notice'].to_i].max
          button.remove
        end
      end

    ClientMouseDown: |
      client_id, mouse_button = argv
      client = Client.new(client_id)
      case mouse_button.to_i
      when 1 then
        client.focus
      when 3 then
        case click_menu %w[stick group fullscreen kill slay], 'client'
        when 'stick'      then client.stick!
        when 'group'      then client.group!
        when 'fullscreen' then client.fullscreen!
        when 'kill'       then client.kill
        when 'slay'       then client.slay
        end
      when 4 then
        curr_view.select(:up) rescue nil
      when 5 then
        curr_view.select(:down) rescue nil
      when 6 then
        grouping.each {|c| c.send(:left) rescue nil }
        if View.curr.manifest =~ /# \d+ (\d+) \d+(\n[^#].*)*#{curr_client.id} (\d+)/
          system "swarp #{$1.to_i + 4} #{$3.to_i + 4}"
        end
      when 7 then
        grouping.each {|c| c.send(:right) rescue nil }
        if View.curr.manifest =~ /# \d+ (\d+) \d+(\n[^#].*)*#{curr_client.id} (\d+)/
          system "swarp #{$1.to_i + 4} #{$3.to_i + 4}"
        end
      when 8 then
        grouping.each {|c| c.kill }
      when 9 then
        if client.group?
          Rumai.ungroup
        else
          client.group!
        end
      end

  ##
  # Internal scripts.
  #
  #   <action name>: <Ruby code to execute>
  #
  action:
    exec: | # call exec inside wmii
      if choice = key_menu(['wmii'], 'exec:')
        fs.ctl.write "exec #{choice}"
      end
    reload: | # reload this wmii configuration
      reload_config

    rehash: | # scan for available programs and actions
      @programs = find_programs(ENV['PATH'].squeeze(':').split(':'))

    clear: | # kill all clients
      # firefox's restore session feature does not
      # work unless the whole process is killed.
      system 'killall firefox firefox-bin thunderbird thunderbird-bin'

      # gnome-panel refuses to die by any other means
      system 'killall -s TERM gnome-panel'

      Thread.pass until clients.each do |c|
        begin
          c.focus # XXX: client must be on current view in order to be killed
          c.kill
        rescue
          # ignore
        end
      end.empty?

    kill: | # kill the window manager only; do not touch the clients!
      fs.ctl.write 'quit'

    quit: | # kill both clients and window manager
      action 'clear'
      action 'kill'

##
# Arbitrary logic.
#
#   script:
#     before: <Ruby code to execute before processing this file>
#     after:  <Ruby code to execute after processing this file>
#
script:
  before: |
    DETACHED_TAG  = '|'
    ZOOMED_SUFFIX = /~(\d+)$/
    
    TERMINAL = 'urxvtc'
    XMESSAGE = 'gxmessage'

    require 'tools/pulse.rb'
    @mixer = Pulse.new

  after: |
    action 'rehash'
    fs.ctl.write 'view net' if curr_tag == '1'

    def startup prog, *args
      unless system "ps -e | grep #{prog} > /dev/null"
        launch 'wihack', '-tags', '/./', prog, *args
      end
    end

    startup *%W[stalonetray --icon-gravity SE --grow-gravity W -i 13 -bg #{CONFIG['display']['color']['normal'].split[1]} -geometry 64x12+1506+1038]
    startup 'orage'
    startup 'pidgin'
